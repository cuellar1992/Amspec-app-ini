import{s as p}from"./index-BDXnSKSk.js";function d(e){const t=new Uint8Array(e);let r="";for(const n of t)r+=String.fromCharCode(n);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function E(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),r=(4-t.length%4)%4,a=t.padEnd(t.length+r,"="),n=atob(a),s=new ArrayBuffer(n.length),o=new Uint8Array(s);for(let c=0;c<n.length;c++)o[c]=n.charCodeAt(c);return s}function A(){return I.stubThis((globalThis==null?void 0:globalThis.PublicKeyCredential)!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const I={stubThis:e=>e};function O(e){const{id:t}=e;return{...e,id:E(t),transports:e.transports}}function S(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class i extends Error{constructor({message:t,code:r,cause:a,name:n}){super(t,{cause:a}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=n??a.name,this.code=r}}function T({error:e,options:t}){var a,n,s;const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(((a=r.authenticatorSelection)==null?void 0:a.requireResidentKey)===!0)return new i({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&((n=r.authenticatorSelection)==null?void 0:n.userVerification)==="required")return new i({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(((s=r.authenticatorSelection)==null?void 0:s.userVerification)==="required")return new i({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new i({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return r.pubKeyCredParams.filter(c=>c.type==="public-key").length===0?new i({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new i({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const o=globalThis.location.hostname;if(S(o)){if(r.rp.id!==o)return new i({message:`The RP ID "${r.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(r.user.id.byteLength<1||r.user.id.byteLength>64)return new i({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class N{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const r=new Error("Cancelling existing WebAuthn API call for new one");r.name="AbortError",this.controller.abort(r)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const _=new N,C=["cross-platform","platform"];function P(e){if(e&&!(C.indexOf(e)<0))return e}async function v(e){var g;!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:r=!1}=e;if(!A())throw new Error("WebAuthn is not supported in this browser");const a={...t,challenge:E(t.challenge),user:{...t.user,id:E(t.user.id)},excludeCredentials:(g=t.excludeCredentials)==null?void 0:g.map(O)},n={};r&&(n.mediation="conditional"),n.publicKey=a,n.signal=_.createNewAbortSignal();let s;try{s=await navigator.credentials.create(n)}catch(u){throw T({error:u,options:n})}if(!s)throw new Error("Registration was not completed");const{id:o,rawId:c,response:l,type:y}=s;let h;typeof l.getTransports=="function"&&(h=l.getTransports());let b;if(typeof l.getPublicKeyAlgorithm=="function")try{b=l.getPublicKeyAlgorithm()}catch(u){R("getPublicKeyAlgorithm()",u)}let f;if(typeof l.getPublicKey=="function")try{const u=l.getPublicKey();u!==null&&(f=d(u))}catch(u){R("getPublicKey()",u)}let w;if(typeof l.getAuthenticatorData=="function")try{w=d(l.getAuthenticatorData())}catch(u){R("getAuthenticatorData()",u)}return{id:o,rawId:d(c),response:{attestationObject:d(l.attestationObject),clientDataJSON:d(l.clientDataJSON),transports:h,publicKeyAlgorithm:b,publicKey:f,authenticatorData:w},type:y,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:P(s.authenticatorAttachment)}}function R(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function D(){if(!A())return m.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return(e==null?void 0:e.isConditionalMediationAvailable)===void 0?m.stubThis(new Promise(t=>t(!1))):m.stubThis(e.isConditionalMediationAvailable())}const m={stubThis:e=>e};function K({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const a=globalThis.location.hostname;if(S(a)){if(r.rpId!==a)return new i({message:`The RP ID "${r.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function U(e){var w,g;!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:r=!1,verifyBrowserAutofillInput:a=!0}=e;if(!A())throw new Error("WebAuthn is not supported in this browser");let n;((w=t.allowCredentials)==null?void 0:w.length)!==0&&(n=(g=t.allowCredentials)==null?void 0:g.map(O));const s={...t,challenge:E(t.challenge),allowCredentials:n},o={};if(r){if(!await D())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&a)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');o.mediation="conditional",s.allowCredentials=[]}o.publicKey=s,o.signal=_.createNewAbortSignal();let c;try{c=await navigator.credentials.get(o)}catch(u){throw K({error:u,options:o})}if(!c)throw new Error("Authentication was not completed");const{id:l,rawId:y,response:h,type:b}=c;let f;return h.userHandle&&(f=d(h.userHandle)),{id:l,rawId:d(y),response:{authenticatorData:d(h.authenticatorData),clientDataJSON:d(h.clientDataJSON),signature:d(h.signature),userHandle:f},type:b,clientExtensionResults:c.getClientExtensionResults(),authenticatorAttachment:P(c.authenticatorAttachment)}}class k{async getRegisterOptions(){try{const t=await p.post("/auth/passkey/register-options");if(t.data.success)return t.data.data;throw new Error("Failed to get registration options")}catch(t){throw this.handleError(t)}}async registerPasskey(t){try{if(!this.isSupported())throw new Error("Passkeys are not supported on this device/browser");const r=await this.getRegisterOptions();if(!r||!r.challenge)throw new Error("Invalid registration options received from server");const a=await v({optionsJSON:r}),n=await p.post("/auth/passkey/register-verify",{credential:a,name:t});if(n.data.success)return n.data.data;throw new Error(n.data.message||"Failed to register passkey")}catch(r){throw r instanceof Error&&r.name==="NotAllowedError"?new Error("Passkey registration was cancelled"):this.handleError(r)}}async getLoginOptions(t){try{const r=await p.post("/auth/passkey/login-options",{email:t});if(r.data.success)return r.data.data;throw new Error("Failed to get login options")}catch(r){throw this.handleError(r)}}async authenticateWithPasskey(t){try{if(!this.isSupported())throw new Error("Passkeys are not supported on this device/browser");const{options:r,challenge:a}=await this.getLoginOptions(t),n=await U({optionsJSON:r}),s=await p.post("/auth/passkey/login-verify",{credential:n,challenge:a});if(s.data.success)return s.data.data;throw new Error(s.data.message||"Failed to authenticate with passkey")}catch(r){throw r instanceof Error&&r.name==="NotAllowedError"?new Error("Passkey authentication was cancelled"):this.handleError(r)}}async listPasskeys(){try{const t=await p.get("/auth/passkey/list");if(t.data.success)return t.data.data.passkeys;throw new Error("Failed to list passkeys")}catch(t){throw this.handleError(t)}}async deletePasskey(t){try{const r=await p.delete(`/auth/passkey/${t}`);if(!r.data.success)throw new Error(r.data.message||"Failed to delete passkey")}catch(r){throw this.handleError(r)}}isSupported(){return typeof window<"u"&&window.PublicKeyCredential!==void 0&&typeof window.PublicKeyCredential=="function"}async isPlatformAuthenticatorAvailable(){if(!this.isSupported())return!1;try{return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}catch{return!1}}handleError(t){var r,a,n,s;if(t&&typeof t=="object"&&"response"in t){const o=t,c=((a=(r=o.response)==null?void 0:r.data)==null?void 0:a.message)||"Request error",l=new Error(c);return l.status=(n=o.response)==null?void 0:n.status,l.data=(s=o.response)==null?void 0:s.data,l}else{if(t&&typeof t=="object"&&"request"in t)return new Error("No response received from server");{const o=t instanceof Error?t.message:"Unknown error";return new Error(o)}}}}const x=new k;export{x as p};
